<?xml version="1.0" encoding="UTF-8"?>
<ctl:package 
	xmlns:ctl="http://www.occamlab.com/ctl" 
	xmlns:gml="http://www.opengis.net/gml" 
	xmlns:html="http://www.w3.org/1999/xhtml" 	
	xmlns:ogc="http://www.opengis.net/ogc"
	xmlns:ows="http://www.opengis.net/ows/1.1" 
	xmlns:parsers="http://www.occamlab.com/te/parsers"
	xmlns:saxon="http://saxon.sf.net/" 
	xmlns:tep="http://teamengine.sourceforge.net/parsers" 
	xmlns:xi="http://www.w3.org/2001/XInclude" 
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xml="http://www.w3.org/XML/1998/namespace"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:wmts="http://www.opengis.net/wmts/1.0"
	xmlns:owsFunctions="https://cite.opengeospatial.org/wmts-1.0.0/src/ctl/owsFunctions.xml"	
	xmlns:ctlFunctions="https://cite.opengeospatial.org/wmts-1.0.0/src/ctl/ctlFunctions.xml"	
>

	<ctl:function name="owsFunctions:validateVersion">
		<ctl:param name="versionString"/>
		<ctl:description>Validates that versionString is in x.y.z format with values less than 100</ctl:description>
		<ctl:code>
			<xsl:value-of select="boolean(matches($versionString,'\d\.\d\.\d') and (every $d in tokenize($versionString,'\.') satisfies round(number($d)) lt 100))"/>
		</ctl:code>
	</ctl:function>

	<ctl:function name="owsFunctions:incrementVersion">
		<ctl:param name="versionString"/>
		<ctl:description>Increments the "y" sub-version in a versionString is in x.y.z format.  Used for version negotiation testing.</ctl:description>
		<ctl:code>
			<xsl:message>incrementVersion <xsl:value-of select="$versionString"/></xsl:message>
			<xsl:variable name="versionNumberList" select="tokenize($versionString, '\.')"/>
			<xsl:variable name="newVersion">
				<xsl:value-of select="$versionNumberList[1]"/>
				<xsl:text>.</xsl:text>
				<xsl:variable name="verPlus" select="$versionNumberList[2] + 1"/>
				<xsl:message><xsl:value-of select="concat('verPlus ', $verPlus)"/></xsl:message>
				<xsl:value-of select="$verPlus"/>
				<xsl:text>.</xsl:text>
				<xsl:value-of select="$versionNumberList[3]"/>
			</xsl:variable>
			<xsl:value-of select="string($newVersion)"/>
		</ctl:code>
	</ctl:function>

    <!-- Seed from SOS OWS.xml modified to handle ^ locator and multiple Exception elements.
		   Checks an ExceptionReport for specific exceptionCode and locator values  -->
    <ctl:function name="owsFunctions:checkExceptionReport">
        <ctl:param name="exceptionReport">The exception report to check</ctl:param>
        <ctl:param name="exceptionCodeToCheck">The exceptionCode to check</ctl:param>
        <ctl:param name="locatorToCheck">The locator to check; a * can be provided to indicate that any locator value is allowed; a ^ can be provided to indicate that no locator value is allowed</ctl:param>
        <ctl:return>| separated list of  exceptionCodeToCheck,locatorToCheck,true/false,exceptionCodeValue,locatorValue </ctl:return>
        <ctl:description>Validates an ExceptionReport and checks for specific exceptionCode and locator values</ctl:description>
        <ctl:code>
			<!-- <xsl:message>checkExceptionReport exceptionReport <xsl:copy-of select="$exceptionReport"/></xsl:message> -->
			<xsl:variable name="results">
				<xsl:for-each  select="$exceptionReport//ows:Exception">
					<xsl:variable name="exceptionElement" select="."/>
					<xsl:variable name="exceptionCodeValue" select="$exceptionElement/@exceptionCode" />
					<xsl:variable name="locatorValue" select="$exceptionElement/@locator" />
					<!-- <ctl:message select="concat('checkExceptionReport code ', $exceptionCodeValue, ' value ', $locatorValue)"/> -->
					<xsl:choose>
						<xsl:when test="lower-case(string($exceptionCodeValue)) = lower-case(string($exceptionCodeToCheck))">
						   <xsl:choose>
								<xsl:when test="$locatorToCheck='*'">
									<xsl:value-of select="concat($exceptionCodeToCheck, ',', $locatorToCheck, ',true,', $exceptionCodeValue, ',', $locatorValue, '|') "/>
								</xsl:when>
								<xsl:when test="$locatorToCheck='^'">
									<xsl:value-of select="concat($exceptionCodeToCheck, ',', $locatorToCheck, ',', string(not($locatorValue) or $locatorValue = ''),  ',', $exceptionCodeValue, ',', $locatorValue, '|') "/>          
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="concat($exceptionCodeToCheck, ',', $locatorToCheck, ',', string(contains(lower-case(string($locatorToCheck)), lower-case(string($locatorValue)))), ',', $exceptionCodeValue, ',', $locatorValue, '|') "/> 
								</xsl:otherwise>
							</xsl:choose>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="concat($exceptionCodeToCheck, ',', $locatorToCheck, ',false,', $exceptionCodeValue, ',', $locatorValue, '|') "/>
						</xsl:otherwise>
					</xsl:choose>
 				</xsl:for-each>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="$results and $results != '' ">
					<xsl:value-of select="$results"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>NoExceptionCode,NoLocator,false</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
        </ctl:code>
    </ctl:function>	 

	<ctl:function name="owsFunctions:getServiceURL">
		<ctl:param name="operationURL"/>
		<ctl:description>Strips trailing ? from operationURL if there is one.</ctl:description>
		<ctl:code>
			<xsl:choose>
				<xsl:when test="ends-with($operationURL,'?')">
					<xsl:value-of select="substring-before($operationURL,'?')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$operationURL"/>
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:function>

	<ctl:function name="owsFunctions:provokeKVPGetException">
		<ctl:param name="capabilitiesURL">/wmts:Capabilities/ows:OperationsMetadata/ows:Operation[@name='GetCapabilities']/ows:DCP/ows:HTTP/ows:Get/@xlink:href</ctl:param>
		<ctl:param name="invalidQuery">KVP Get query string to provoke an exception</ctl:param>
		<ctl:param name="exceptionReportSchemaPath">full path to owsExceptionReport.xsd</ctl:param>
		<ctl:param name="exceptionCodes">Exception code, or codes separated by spaces, e.g.  MissingParameterValue InvalidParameterValue</ctl:param>
		<ctl:param name="locators">Locator code or codes, separated by spaces, e.g. service request</ctl:param>
        <ctl:return>true/false depending on whether or not the provoked exception contains the specified exception code(s) and locator(s)</ctl:return>
		<ctl:description>Provokes an ows:ExceptionReport by issuing an invalid KVP Get query to a WMTS server.  The exceptionCodes and locators parameters must contain the same number of codes.</ctl:description>
		<ctl:code>
			<xsl:variable name="invalidQueryString">
				<xsl:choose>
					<xsl:when test="ends-with($capabilitiesURL,'?')">
						<xsl:value-of select="concat($capabilitiesURL, $invalidQuery)"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat($capabilitiesURL,'?',$invalidQuery)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<ctl:message select="concat('Invalid Query String: ', $invalidQueryString)"/>		
			<xsl:variable name="testResult">
				<xsl:choose>
					<xsl:when test="count(exceptionCodes) = count(locators)">
						<xsl:variable name="response">
							<ctl:request>
								<ctl:url>
									<xsl:value-of select="$invalidQueryString"/>
								</ctl:url>
								<ctl:method>get</ctl:method>
								<parsers:HTTPParser>
								   <parsers:parse>
									   <!-- <parsers:NullParser/> don't echo response -->
										<parsers:XSLTransformationParser resource="rewriteNonException.xsl"/> 
								   </parsers:parse>
								</parsers:HTTPParser>
							</ctl:request>
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="not($response/response/contents/*)">
								<ctl:message>FAILURE: Missing or invalid response entity contents; should have been an ows:ExceptionReport.</ctl:message>
								<xsl:text>false</xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<ctl:call-function name="owsFunctions:validateExceptionReport">
									<ctl:with-param name="httpParserExceptionReport" select="$response"/>
									<ctl:with-param name="exceptionReportSchemaPath" select="$exceptionReportSchemaPath"/>
									<ctl:with-param name="exceptionCodes" select="$exceptionCodes"/>
									<ctl:with-param name="locators" select="$locators"/>
								</ctl:call-function>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<ctl:message><xsl:value-of select="concat('Count of exceptionCodes (', count(exceptionCodes), ') does not match count of locators (', count(locators), '), test fails')"/></ctl:message>
						<xsl:text>false</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:value-of select="$testResult"/>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="owsFunctions:validateExceptionReport">
		<ctl:param name="httpParserExceptionReport">/response/content/* is ows:ExceptionReport returned from query</ctl:param>
		<ctl:param name="exceptionReportSchemaPath">full path to owsExceptionReport.xsd</ctl:param>
		<ctl:param name="exceptionCodes">Exception code, or codes separated by commas, e.g.  MissingParameterValue,InvalidParameterValue</ctl:param>
		<ctl:param name="locators">Locator code or codes, separated by commas, e.g. service,request</ctl:param>
        <ctl:description>Validates an ExceptionReport and checks for supplied exceptionCode(s) and locator value(s)</ctl:description>
		<ctl:code>
			<ctl:message select="concat('Validating ows:ExceptionReport against its XML Schema ', $exceptionReportSchemaPath, ' for codes ', $exceptionCodes, ' locators ', $locators)"/> 
			<ctl:call-function name="ctl:startStopwatch">
				<ctl:with-param name="watchName">exception.validation</ctl:with-param>
			</ctl:call-function>
			<!-- <xsl:message>validateExceptionReport httpParserExceptionReport  <xsl:copy-of select="$httpParserExceptionReport"/></xsl:message> -->
			<!-- <xsl:copy-of select="$httpParserExceptionReport"/> -->
			<xsl:variable name="exceptionReport" select="$httpParserExceptionReport/response/content/*"/>
			<!-- <xsl:message>validateExceptionReport exceptionReport <xsl:copy-of select="$exceptionReport"/></xsl:message> -->
			<!-- <ctl:message select="concat('validateExceptionReport schemaPath ', $exceptionReportSchemaPath)"/> -->
			<xsl:variable name="results">
				<ctl:call-function name="ctlFunctions:XMLschemaValidate">
					<ctl:with-param name="doc"><xsl:copy-of select="$exceptionReport"/></ctl:with-param>
					<ctl:with-param name="schemaPath" select="$exceptionReportSchemaPath"/>
				</ctl:call-function>
			</xsl:variable>
			<xsl:variable name="exception.validation.elapsed" select="ctl:elapsedTime('exception.validation')"/>
			<xsl:choose>
				<xsl:when test="count($results/*) &gt; 0">
					<ctl:message>Exception report failed schema validation; elapsedTime: [<xsl:value-of select="$exception.validation.elapsed"/>] milliseconds</ctl:message>
					<ctl:message>results: <xsl:copy-of select="$results"/></ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>exception.validation.elapsed [<xsl:value-of select="$exception.validation.elapsed"/>] milliseconds</ctl:message>
					<ctl:message>Exception report is XML Schema valid, continuing...</ctl:message>
					<xsl:variable name="exceptionCodeList" select="tokenize($exceptionCodes, ',')"/>
					<xsl:variable name="locatorList" select="tokenize($locators, ',')"/>
					<xsl:variable name="exceptionReportResults">
						<xsl:for-each select="1 to count($locatorList)">
							<xsl:variable name="pos" select="."/>
							<xsl:variable name="exceptionCode" select="$exceptionCodeList[$pos]"/>
							<xsl:variable name="locator" select="$locatorList[$pos]"/>
							<!-- <ctl:message select="concat('owsFunctions:validateExceptionReport code ', $exceptionCode, ' locator ', $locator)"/> -->
							<xsl:variable name="result">
								<ctl:call-function name="owsFunctions:checkExceptionReport">
									<ctl:with-param name="exceptionReport" select="$exceptionReport" />
									<ctl:with-param name="exceptionCodeToCheck" select="$exceptionCode" />
									<ctl:with-param name="locatorToCheck" select="$locator" />
								</ctl:call-function>
							</xsl:variable>
							<xsl:variable name="toCheckTrue" select="concat($exceptionCode, ',', $locator, ',true')"/>
							<xsl:variable name="exceptionCodeTrue" select="contains($result, $toCheckTrue)"/>		
							<!-- <ctl:message select="concat('toCheckTrue ', $toCheckTrue, ' exceptionCodeTrue ', $exceptionCodeTrue)"/>			-->		
							<xsl:variable name="resultList" select="tokenize($result, '\|')"/>
							<xsl:for-each select="$resultList">
								<xsl:variable name="oneResult" select="."/>
								<xsl:if test="$oneResult and $oneResult != '' ">
									<!-- <ctl:message select="concat('oneResult ', $oneResult)"/> -->
									<xsl:variable name="codeLocatorResult" select="tokenize($oneResult, ',')"/>
									<xsl:variable name="resultReturned" select="$codeLocatorResult[3]"/>
									<xsl:variable name="exceptionCodeReturned" select="$codeLocatorResult[4]"/>
									<xsl:variable name="locatorReturned" select="$codeLocatorResult[5]"/>
									<!-- <ctl:message select="concat('exceptionCodeReturned ', $exceptionCodeReturned, ' locatorReturned ', $locatorReturned, ' resultReturned ', $resultReturned)"/> -->
									<xsl:choose>
										<xsl:when test="lower-case(string($exceptionCodeReturned)) = lower-case(string($exceptionCode))">
											<xsl:choose>
												<xsl:when  test="$resultReturned = 'true' ">
													<ctl:message select="concat('The returned exception report contained expected exceptionCode ', $exceptionCode, ' with locator ', $locatorReturned, ' valid for specified locator ', $locator)"/>
													<xsl:text>true|</xsl:text>
												</xsl:when>
												<xsl:when test="not($exceptionCodeTrue)">
													<ctl:message select="concat('The returned exception report contained expected exceptionCode ', $exceptionCode, ' with locator ', $locatorReturned, ' not valid for specified locator ', $locator)"/>
													<xsl:text>false|</xsl:text>
												</xsl:when>
											</xsl:choose>
										</xsl:when>
										<xsl:otherwise>
											<xsl:if test="not(contains($exceptionCodes, $exceptionCodeReturned))">
												<ctl:message select="concat('The returned exception report contained unexpected exceptionCode ', $exceptionCodeReturned, ' with locator ', $locatorReturned)"/>
											</xsl:if>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:for-each>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="not(contains($exceptionReportResults, 'true')) or contains($exceptionReportResults, 'false')">
							<ctl:message>Exception report does not contain required valid exception code(s) and locator(s)</ctl:message>
							<xsl:text>false</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<ctl:message>Exception report contains required valid exception code(s) and locator(s)</ctl:message>
							<xsl:text>true</xsl:text>
							</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>	
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="owsFunctions:kvpUpdateSequenceValuesEqual">
		<ctl:param name="capabilitiesURL"/>
		<ctl:param name="method">get|post</ctl:param>
		<ctl:param name="wmtsSchemaPath">full path to wmts.xsd</ctl:param>
		<ctl:param name="wmtsSchemaType">url | file | resource</ctl:param>
		<ctl:param name="wmtsVersion"/>
		<ctl:param name="updateSequence"/>
		<ctl:return>true|false</ctl:return>
		<ctl:description>Performs KVP GetCapabilities UpdateSequence test where Operation Request and Service Metadata updateSequence values are equal.</ctl:description>
		<ctl:code>
			<xsl:variable name="serviceURL" select="owsFunctions:getServiceURL($capabilitiesURL)"/>
			<ctl:message select="concat('Sending KVP ', $method, ' GetCapabilities request to ', $serviceURL, ' with optional parameter updateSequence = ', $updateSequence, ' and validating response.' )"/>
			<xsl:variable name="response">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$serviceURL"/>
					</ctl:url>
					<ctl:method><xsl:value-of select="$method"/></ctl:method>
					<ctl:param name="service">WMTS</ctl:param>
					<ctl:param name="request">GetCapabilities</ctl:param>
					<ctl:param name="version"><xsl:value-of select="$wmtsVersion"/></ctl:param>
					<ctl:param name="updateSequence"><xsl:value-of select="$updateSequence"/></ctl:param>
					<parsers:XMLValidatingParser>
						<parsers:schemas>
							<parsers:schema type="url">http://www.w3.org/2001/xml.xsd</parsers:schema>
							<parsers:schema>
								<xsl:attribute name="type"><xsl:value-of select="$wmtsSchemaType" /></xsl:attribute>
								<xsl:value-of select="$wmtsSchemaPath" />
							</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>
				</ctl:request>
			</xsl:variable>		
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>kvpUpdateSequenceValuesEqual missing or invalid response entity; should have been a WMTS Capabilities document.</ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:otherwise>		
					<xsl:variable name="capabilitiesElement" select="$response/wmts:Capabilities"/>
					<xsl:choose>
						<xsl:when test="count($capabilitiesElement/*) gt 0">
							<ctl:message>kvpUpdateSequenceValuesEqual returned capabilities document contains element content when it should not.</ctl:message>
							<xsl:text>false</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<xsl:variable name="versionReturned" select="$capabilitiesElement/@version"/>
							<xsl:variable name="updateSequenceReturned" select="$capabilitiesElement/@updateSequence"/>
							<xsl:choose>
								<xsl:when test="not($versionReturned) or $versionReturned = '' or not($updateSequenceReturned) or $updateSequenceReturned = '' ">
									<ctl:message select="concat('kvpUpdateSequenceValuesEqual returned capabilities document without valid version ', $versionReturned, ' or update sequence ', $updateSequenceReturned, ' attributes.')"/>
									<xsl:text>false</xsl:text>
								</xsl:when>
								<xsl:otherwise>
									<ctl:message select="concat('kvpUpdateSequenceValuesEqual returned capabilities document with valid version ', $versionReturned, ' and update sequence ', $updateSequenceReturned, ' attributes.')"/>
									<xsl:text>true</xsl:text>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="owsFunctions:kvpUpdateSequenceValueLess">
		<ctl:param name="capabilitiesURL"/>
		<ctl:param name="method">get|post</ctl:param>
		<ctl:param name="wmtsSchemaPath">full path to wmts.xsd</ctl:param>
		<ctl:param name="wmtsSchemaType">url | file | resource</ctl:param>
		<ctl:param name="wmtsVersion"/>
		<ctl:param name="updateSequence"/>
		<ctl:return>true|false</ctl:return>
		<ctl:description>Performs KVP GetCapabilities UpdateSequence test where Operation Request update Sequence is less than that in the Service Metadata.</ctl:description>
		<ctl:code>
			<xsl:variable name="serviceURL" select="owsFunctions:getServiceURL($capabilitiesURL)"/>
			<ctl:message select="concat('Sending KVP ', $method, ' GetCapabilities request to ', $serviceURL, ' with optional parameter updateSequence = ', $updateSequence, ' and validating response.' )"/>
			<xsl:variable name="response">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$serviceURL"/>
					</ctl:url>
					<ctl:method><xsl:value-of select="$method"/></ctl:method>
					<ctl:param name="service">WMTS</ctl:param>
					<ctl:param name="request">GetCapabilities</ctl:param>
					<ctl:param name="version"><xsl:value-of select="$wmtsVersion"/></ctl:param>
					<ctl:param name="updateSequence"><xsl:value-of select="$updateSequence"/></ctl:param>
					<parsers:XMLValidatingParser>
						<parsers:schemas>
							<parsers:schema type="url">http://www.w3.org/2001/xml.xsd</parsers:schema>
							<parsers:schema>
								<xsl:attribute name="type"><xsl:value-of select="$wmtsSchemaType" /></xsl:attribute>
								<xsl:value-of select="$wmtsSchemaPath" />
							</parsers:schema>
						</parsers:schemas>
					</parsers:XMLValidatingParser>
				</ctl:request>
			</xsl:variable>		
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>kvpUpdateSequenceValuesEqual missing or invalid response entity; should have been a WMTS Capabilities document.</ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:otherwise>		
					<xsl:variable name="capabilitiesElement" select="$response/wmts:Capabilities"/>
					<xsl:variable name="versionReturned" select="$capabilitiesElement/@version"/>
					<xsl:variable name="updateSequenceReturned" select="$capabilitiesElement/@updateSequence"/>
					<xsl:choose>
						<xsl:when test="not(number($updateSequenceReturned) gt number($updateSequence))">
							<ctl:message select="concat('kvpUpdateSequenceValueLess returned capabilities document contains request updateSequence value ', $updateSequenceReturned, ' instead of current one')"/>
							<xsl:text>false</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<ctl:message select="concat('kvpUpdateSequenceValueLess returned capabilities document with version ', $versionReturned, ' and current updateSequence ', $updateSequenceReturned)"/>
							<xsl:text>true</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:function>
	
	<ctl:function name="owsFunctions:kvpUpdateSequenceValueGreater">
		<ctl:param name="capabilitiesURL"/>
		<ctl:param name="method">get|post</ctl:param>
		<ctl:param name="exceptionReportSchemaPath">full path to owsExceptionReport.xsd</ctl:param>
		<ctl:param name="wmtsVersion"/>
		<ctl:param name="updateSequence"/>
		<ctl:return>true|false</ctl:return>
		<ctl:description>Performs KVP GetCapabilities UpdateSequence test where Operation Request update Sequence is greater than that in the Service Metadata.</ctl:description>
		<ctl:code>
			<ctl:message select="concat('Sending KVP ', $method, ' GetCapabilities request to ', $capabilitiesURL, ' with optional parameter updateSequence = ', $updateSequence, ' and validating response.' )"/>
			<xsl:variable name="invalidQuery" select="concat('service=WMTS&amp;request=GetCapabilities&amp;version=', $wmtsVersion, '&amp;updateSequence=', $updateSequence)"/>
			<xsl:variable name="testResult">
				<ctl:call-function name="owsFunctions:provokeKVPGetException">
					<ctl:with-param name="capabilitiesURL" select="$capabilitiesURL"/>
					<ctl:with-param name="invalidQuery" select="$invalidQuery"/>
					<ctl:with-param name="exceptionReportSchemaPath" select="$exceptionReportSchemaPath"/>
					<ctl:with-param name="exceptionCodes">InvalidUpdateSequence</ctl:with-param>
					<ctl:with-param name="locators">^</ctl:with-param>
				</ctl:call-function>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="$testResult = 'true' ">
					<ctl:message>Server returned correct ows:ExceptionReport and HTTP status in response to kvpUpdateSequenceValueGreater request with an updateSequence parameter with an invalid value, so test passes.</ctl:message>
					<xsl:text>true</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>Server did not return a correct ows:ExceptionReport and HTTP status in response to kvpUpdateSequenceValueGreater request with an updateSequence parameter with an invalid value.')"/></ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:function>

	<ctl:function name="owsFunctions:kvpAcceptFormats">
		<ctl:param name="capabilitiesURL"/>
		<ctl:param name="method">get|post</ctl:param>
		<ctl:param name="serviceType">OWS service type, e.g. WMTS</ctl:param>
		<ctl:param name="format">valid MIME type format from capabilities document accept formats values, or 'bogus/xml'</ctl:param>
		<ctl:param name="wmtsSchemaPath">full path to wmts.xsd</ctl:param>	
		<ctl:return>true|false</ctl:return>
		<ctl:description>Performs KVP GetCapabilities AcceptFormats test</ctl:description>
		<ctl:code>
			<xsl:variable name="serviceURL" select="owsFunctions:getServiceURL($capabilitiesURL)"/>
			<ctl:message select="concat('Sending KVP ', $method, ' GetCapabilities request to ', $serviceURL, ' with optional parameter acceptFormats = ', $format, ' and validating response.' )"/>
			<xsl:variable name="response">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$serviceURL"/>
					</ctl:url>
					<ctl:method><xsl:value-of select="$method"/></ctl:method>
					<ctl:param name="service"><xsl:value-of select="$serviceType" /></ctl:param>
					<ctl:param name="request">GetCapabilities</ctl:param>
					<ctl:param name="acceptformats"><xsl:value-of select="$format"/></ctl:param>
					<parsers:HTTPParser>
						 <parsers:parse>
							<!-- <parsers:NullParser/> don't echo response -->
							<parsers:XSLTransformationParser resource="rewriteNonException.xsl"/> 
						</parsers:parse>
					</parsers:HTTPParser>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="contentType" select="$response/response/headers/header[@name='Content-Type']"/>
			<xsl:choose>			
				<xsl:when test="not($response/*)">
					<ctl:message>FAILURE: Missing or invalid response entity contents; should have been a WMTS capabilties document.</ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:when test="$format = 'bogus/xml' and $contentType != 'application/xml.' ">
					<ctl:message>FAILURE: Unexpected content type for response entity (Invalid Request format: <xsl:value-of select="$format"/>, Response format: <xsl:value-of select="$contentType"/>).</ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:when test="not(starts-with($contentType, $format))">
					<ctl:message>FAILURE: Unexpected content type for response entity (Request format: <xsl:value-of select="$format"/>, Response format: <xsl:value-of select="$contentType"/>).</ctl:message>
					<xsl:text>false</xsl:text>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message>Request: format <xsl:value-of select="$format"/> matches Response format: <xsl:value-of select="$contentType"/>).</ctl:message>
					<ctl:message>Validating capabilities document against its XML Schema wmts.xsd</ctl:message>
					<ctl:call-function name="ctl:startStopwatch">
						<ctl:with-param name="watchName">schema.validation</ctl:with-param>
					</ctl:call-function>
					<xsl:variable name="wmts.capabilities.doc" select="$response/response/content/*"/>
					<xsl:variable name="results">
						<ctl:call-function name="ctlFunctions:XMLschemaValidate">
							<ctl:with-param name="doc"><xsl:copy-of select="$wmts.capabilities.doc"/></ctl:with-param>
							<ctl:with-param name="schemaPath" select="$wmtsSchemaPath"/>
						</ctl:call-function>
					</xsl:variable>
					<xsl:variable name="schema.validation.elapsed" select="ctl:elapsedTime('schema.validation')"/>
					<xsl:choose>
						<xsl:when test="count($results/*) &gt; 0">
							<ctl:message>WMTS capabilities document failed schema validation; elapsedTime: [<xsl:value-of select="$schema.validation.elapsed"/>] milliseconds</ctl:message>
							<ctl:message>results: <xsl:copy-of select="$results"/></ctl:message>
							<xsl:text>false</xsl:text>
						</xsl:when>
						<xsl:otherwise>
							<ctl:message>schema.validation.elapsed [<xsl:value-of select="$schema.validation.elapsed"/>] milliseconds</ctl:message>
							<ctl:message>WMTS capabilities document is XML Schema valid</ctl:message>
							<xsl:text>true</xsl:text>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</ctl:code>
	</ctl:function>
	
</ctl:package>
